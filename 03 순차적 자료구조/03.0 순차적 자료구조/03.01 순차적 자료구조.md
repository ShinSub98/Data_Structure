## 순차적 자료구조(Sequential Data structure)

### 배열(Array) / 리스트(List)
배열과 리스트는 가장 기본적인 ==순차적(Sequential) 자료구조==이다.

> [!info] **순차적 자료구조(Sequential Data structure)**
> 순차적 자료구조란, 각 값들이 인덱스(index)에 따른 순서를 가져 일렬로 늘어선 자료구조를 의미한다.

**요약**

|                     |  배열   |  리스트   |
| -------------------:|:-------:|:---------:|
|         **자료의 형태** |  일렬   |  뿔뿔이   |
| **담을 수 있는 자료형** | 한 가지 | 여러 가지 |
|  **값을 불러오는 시간** |  상수   |   값마다 상이    |
|      **용량 자동 조절** |  불가   | 가능          |


#### 배열(Array)
- 한 가지 자료형만 가질 수 있는 순차적 자료구조
- 각 값은 일정한 간격(=해당 배열 자료형의 용량)만큼 떨어져 있다.
- **가용 용량이 먼저 할당**되어 그 이상 사용하기 위해서는 별도의 명령이 필요하다.

> [!example] 
> **배열에서 값을 읽어오는 방법**
int 배열 A\[0]의 메모리 주소값이 100이라고 가정해보자.
이 때 각 자료는 int의 용량인 4byte 간격으로 떨어져 있으며
A\[$x$]의 주소값은 $100 + 4x$이다.
즉, 배열은 '곱하기'와 '더하기'의 연산 두번을 통한 **상수 시간에 자료를 읽어올 수 있다.** 


#### 리스트(List)
- 다양한 자료형을 가질 수 있는 순차적 자료구조
- 각 인덱스는 개별적인 메모리 주소값을 가리킨다.
- **Dynamic array**: 프로그램이 스스로 자료구조의 용량(Capacity)을 탄력적으로 조절한다.

> [!example] 
> **리스트에서 값을 읽어오는 방법**
리스트는 배열과 다르게 다양한 자료형을 담을 수 있는 자료구조이다.
그렇기 때문에 각 자료의 주소는 나란하지 않으며
각각의 인덱스들은 단지 해당 객체의 위치를 가리킬 뿐이다.

**Dynamic array의 알고리즘**
할당된 용량(= capacity)가 A.c, 저장된 용량이 A.n인 리스트가 있으며
x라는 값을 새롭게 저장한다고 가정했을 때
```python
A.append(x):
	if A.n < A.c: #할당된 용량으로 충당 가능할 때
		A[n] = x #마지막 자리에 x를 추가
		A.n = n+1 #x로 인한 용량 변경 사항을 A.n에 반영
	
	elif A.n == A.c: #할당된 용량이 모두 찬 상태라면
		B = A.c*2 # A보다 두배의 용량이 할당된 새로운 리스트 B 생성
		for i in range(n):
			B[i] = A[i] #A의 내용을 B에 복사
		del A #기존 A 삭제
		A = B #옮겨진 리스트B의 이름을 A로 변경
```


> [!abstract] 배열과 리스트의 정의
> - 인덱스(index)로 임의의 원소에 접근할 수 있다.
> - 연산자\[ ]를 사용한다. (\[ ]는 $O(1)$이다.)
> - append / pop은 맨 뒤 원소에 대해 작용한다.
> - insert / remove는 중간에 있는 원소에 대해 작용하며, 뒤에 위치한 원소들의 자리를 옮기는 연산을 해야 한다.
> 	- 이는 $O(1)$만큼의 연산이 필요하며, 자료구조의 맨 앞을 수정하는 최악의 경우 $O(n)$번의 연산이 필요하다.



## 스택(Stack) / 큐(Queue) / 덱(Deque)
스택, 큐, 덱는 굉장히 ==제한된 접근(삽입/삭제)만 허용하는 순차적 자료구조==이다.

> [!note] 접근을 제한한 자료구조를 사용하는 이유
> **사용 가능한 명령어의 개수를 최소화**해 개발자의 실수를 줄이기 위해 사용한다.
