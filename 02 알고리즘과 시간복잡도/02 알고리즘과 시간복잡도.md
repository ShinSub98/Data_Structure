자료구조와 알고리즘은 <u>간단한 코드로 표현</u>한다.
하지만 같은 코드라고 하더라도 프로그램이 실행되는 환경이나 입력값등이 상이하기 때문에
이런 것에 영향을 받지 않는 ==가상 컴퓨터 모델==이 필요하다.

**가상 컴퓨터**(Virtual Machine) + **가상 언어**(Pseudo Language) + **가상 코드**(Pseudo Code)
를 통해 알고리즘의 성능을 <u>객관적</u>으로 비교할 수 있다.


## 가상 컴퓨터(Virtual Computer)
- **Turing Machine**: 최초의 가상 컴퓨터
	- RAM(Random Access Machine) 모델: CPU + 메모리 + 기본 연산
		- ==기본 연산==: 단위 시간에 수행되는 연산들
		- RAM에서 알고리즘을 실행하여 코드의 성능을 측정 


* ==**기본 연산**==
	* RAM 모델에서 단위 시간에 수행되는 연산
	* 단위시간(1) 동안 수행한다고 가정하는 연산들
		- 배정, 대입, 복사 연산: `A = B`로 A를 초기화
		- 산술 연산: +, −, ×, ÷
		- 논리 연산: and, or, not
		- bit-논리 연산: bit-and, bit-or, bit-not


### 가상 언어(Pseudo/Virtual Language)
가상 컴퓨터에서 **시뮬레이션**되는 코드 (실제 작동시키는 것이 아니다.)

- ==구성요소==
	- 배정, 산술, 비교, 논리, bit-논리 연산 등의 "**기본 연산**" → 기존 언어 사용
	- if, elif, else 구조의 비교, 제어, 명령어
	- 반복문: for, while...
	- 함수: 함수를 정의, 호출, return 할 수 있는 문법


### 가상 코드(Pseudo Code)
**실제 실행할 수는 없으나** 컴퓨터 언어와 유사한 수준에서 프로그램의 논리를 설명한 코드.
언어에 구애받지 않고 이해할 수 있는 수준으로 간략하게 작성한다.

예시)
```
algorithm ArrayMax(A, n)
input: n개의 정수를 갖는 배열 A
output: 배열 A 중 최댓값 return

for i = 1 to n-1 do [[A]][1]부터 A[n-1]까지 시도
	if CurrentMax < A[i]:
		CurrentMax = A[i]
return CurrentMax
```

A = \[3, -1, 9, 2, 12]일 경우, CurrentMax는 A\[0]이기 때문에 최초에 3이 된다.
이후 A\[1]인 -1과 비교하여 += 단위시간 1
A\[2]인 9와 비교하여 += 단위시간 1
3 < 9이므로 CurrentMax에 9를 초기화하여 += 단위시간 1
A\[3]인 2와 비교하여 += 단위시간 1
A\[4]인 12와 비교하여 += 단위시간 1
9 < 12이므로 CurrentMax에 12를 초기화하여 += 단위시간 1
→ 기본연산을 총 **7회 반복**했다.



## 시간복잡도
- ==**시간복잡도(Time Complexity)**==: 알고리즘이 수행되는 시간
	- input size: 알고리즘에 입력되는 데이터 크기
	- 시간복잡도를 계산하는 방법
		1. 모든 입력 경우에 수의 대한 기본 연산 계산 (<u>현실적으로 불가능</u>)
		2. **Worst Time Complexity(WTC)**: 가장 연산이 오래 걸리는 경우의 수에 대한 기본연산 횟수를 측정. 어떤 입력에 대해서도 WTC보다 수행시간이 짧다고 예측할 수 있다.


### 시간복잡도 계산
알고리즘의 시간 복잡도는 **T(n)으로 표현**하며, <u>n은  input size</u>를 의미한다.
예를 들어 위 algorithm MaxArray(A, n)의 시간 복잡도는 T(n) = 2n-1이다. 

예시)
==1번 케이스==
```
algorithm sum1(A,n):
	sum = 0
		for i = 0 to n-1 do
			if A[i] % 2 == 0:
				sum += A[i]
	return sum
```

* WTC: 조건문이 없기 때문에 **모든 입력 경우가 WTC**
> 최초에 sum에 0을 초기화 하여 +1
> A\[i]와 2에 대한 나머지 연산을 매번 수행하므로 +n
> A\[i]%2가 0인지 확인하는 연산을 매번 수행하므로 +n
> “sum += A\[i]”의 문장은 “sum = sum + A\[i]”라는 뜻이므로 ‘더하기’와 ‘저장’이라는 두 가지의 기본 연산을 수행하므로 +2n
> 따라서 **T(n) = 4n+1**


==2번 케이스==
```
algorithm sum2(A,n):
	sum = 0
		for i = 0 to n-1 do
			for j = i to n-1 do
				sum += A[i] * A[j]
	return sum
```

* WTC: 조건문이 없기 때문에 **모든 입력 경우가 최악의 WTC**
> 최초에 sum에 0을 초기화 하여 +1
> 
> i의 반복문은 n번 반복 → **n**
> 
> **여기서부터 중첩 반복문**
> j 반복 1회 당 A\[i]와 A\[j]에 대한 곱하기를 매번 수행하므로 +n
> 이후 sum에 더하므로 +n
> 이후 sum에 sum + (A\[i] × A\[j])를 저장하므로 +n
> → j 한 번에 총 3개의 기본 연산
> **여기까지 j(= n-i)를 한 번 반복할 때의 시간복잡도**
> 
> 이러한 j의 반복 횟수는 n, n-1, n-2 … 1까지 이어지기 때문에
> n! = (n(n+1))/2로 표현할 수 있다.
> 즉 이 중첩 반복문은 총 3(n(n+1))/2번 반복한다.
> 
> 따라서 T(n) = 3(n(n+1))/2 + 1


### Big-O
알고리즘의 **시간복잡도 T(n)은 n에 대한 그래프로 표현할 수 있으며**
n이 제곱으로 표현된 경우 n이 커질수록 수행시간의 증가율도 증가한다.
따라서 n의 지수가 클수록 WTC의 증가율도 크게 증가하기 때문에 이 지수값을 비교하기 위한 방법이 ==Big-O==이다.

==**Big-O**==: 알고리즘의 수행시간을 $O(n^x)$의 형태로 **함수의 최고차항만 표기**하여 간단하게 표시
즉, **$O(n^x)$는 $x$차식으로 이루어진 모든 알고리즘을 포함하는 집합이다.**

- 예시)
	1. $T(n) = 2n-1$ → $T(n) = O(n)$
	2. $T(n) = 3n^2 + 1$ → $T(n) = O(n^2)$
	3. $T(n) = 4$ → $T(n) = O(1)$
	4. n이 로그로 표현되는 알고리즘일 경우 → $T(n) = O(\log_a n)$

+) n이 로그로 표현되는 알고리즘
```python
def numberofbits(n):
	count = 0
	while n>0:
		n = n//2
		count += 1
	return count
```
이 알고리즘의 경우 $T(n) = 4\log_2 n + 1$이기 때문에 $T(n) = O(\log_2 n)$으로 표현한다.

