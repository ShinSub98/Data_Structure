- ==**이진탐색트리(Binary Search Tree)**==: 노드를 빠르게 탐색하기 위한 이진트리 형태
	- 각 노드의 Key는 왼쪽 부트리의 Key보다 크거나 같아야 한다
	- 각 노드의 Key는 오른쪽 부트리의 Key보다 작아야 한다

> [!summary] 노드별 크기 관계
>  왼쪽 부트리 ≤ 부모 노드 < 오른쪽 부트리


## 이진탐색트리의 연산
- `find_loc(x)`: x를 Key로 가지고 있는 노드를 리턴하고, 만약 없다면 해당 노드가 삽입될 자리의 부모 노드를 리턴
	1. 루트 노드의 Key와 x를 비교한다.
	2. Key == x라면 해당 노드를 리턴한다.
	3. Key < x라면 오른쪽 자식 노드를 확인하여 반복한다.
	4. x < Key라면 왼쪽 자식 노드를 확인하여 반복한다.
	5. 만약 찾지 못했다면 해당 노드의 부모 노드가 될 노드를 리턴한다.
- `insert(x)`: 트리에 x를 Key로 갖는 노드를 삽입
	1. `find_loc(x)`를 통해 해당 노드가 삽입될 위치를 확인한다.
	2. 이미 x를 Key로 갖는 노드가 존재한다면 오류문을 리턴한다.
	3. x를 Key로 갖는 노드가 없다면 해당 위치에 노드를 삽입하고 size값을 1 더한다.
- `deleteByMerging(x)`: 노드 x를 삭제하고 부트리로 대체
	- 노드 x에 왼쪽 부트리가 없다면 그 자리를 x의 오른쪽 부트리가 대체한다.
	- 노드 x에 왼쪽 부트리가 있다면 그 자리를 x의 왼쪽 부트리가 대체한다.
	- 대체된 왼쪽 부트리에서 가장 Key가 큰 노드 밑에 오른쪽 부트리를 병합한다.
- `deleteByCopying(x)`: 노드 x를 삭제하고 왼쪽 자식 트리에서 가장 큰 Key를 가진 노드로 대체
	- 노드 x를 삭제한 후, 그 왼쪽 부트리에서 가장 큰 Key를 가진 노드를 해당 위치로 이동시킨다.
	- 이동된 왼쪽 자식노드가 있던 위치에는 그 왼쪽 자식 노드가 이동한다.

> [!note] `deleteByMerging`, `deleteByCopying`
>  `deleteByMerging`과 `deleteByCopying`의 인자 x는 Key가 아니라 노드 객체 그 자체이다.


### 이진탐색트리의 시간복잡도

|         연산         | 수행시간 |
|:--------------------:|:--------:|
|     `insert(x)`      |  $O(h)$  |
| `search(x)` |  $O(h)$  |
| `find_loc(x)` |  $O(h)$  |
| `deleteByMerging(x)` |  $O(h)$  |
| `deleteByCopying(x)` |  $O(h)$  |

> [!note] 이진탐색트리의 시간복잡도
>  이진탐색트리는 연산 속도를 중시한 자료구조인 만큼, 모든 연산이 $O(h)$ 안에 가능하다.
>  따라서 이진탐색트리의 연산속도는 트리 높이에 따르기 때문에 트리의 높이를 최대한 낮추는 것이 중요하다. 이를 위한 이진트리의 형태가 "균형이진탐색트리"이다.